[{"content":"\n\ngo语言defer声明调用的函数会在函数结束后才会执行。对于回收资源和释放锁这种容易忘记但又必须做的操作，defer很方便，又不容易忘记。最近使用遇见一些注意项mark一下：  \n###  LIFO \n栈是的后进先出，对于有顺序的资源释放要注意。\n### 先判断返回错误，在defer释放资源  \n对于有些资源的申请，一般会返回错误，在用defer释放资源是一定要先判断是否有错误产生。如果有错误产生这时候是不用释放资源的，因为资源就没有分配，我就遇到过一次发送网络请求后，没有判断错误就```defer resp.Body.Close()```,导致在网络请求失败时释放资源出错。\n### 一个defer做一件事  \n一个defer做一件事，当有多个资源需要释放是，放到不同的defer里，因为万一defer中有代码执行出错，后面的资源就不会释放了。直接看例子：\n```go  \npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    func() {\n        defer func() {\n            fmt.Println(\"1\")\n            fmt.Println(\"2\")\n            panic(\"after 2\")\n            fmt.Println(\"3\")\n        }()\n    }()\n    fmt.Println(\"Hello, 世界\")\n}\n```\n运行结果:\n```\n1\n2\npanic: after 2\n\ngoroutine 1 [running]:\nmain.main.func1.1()\n    /tmp/sandbox790552561/main.go:10 +0x180\nmain.main.func1()\n    /tmp/sandbox790552561/main.go:13 +0x7b\nmain.main()\n    /tmp/sandbox790552561/main.go:13 +0x20\n```\n以上程序的假设打印2后程序错误，会导致3没有打印出来，如果把每件事分开：\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    func() {\n       defer func() {\n           fmt.Println(\"1\")\n        }()\n        defer func() {\n            fmt.Println(\"2\")\n            panic(\"after 2\")\n        }()\n        defer func() {\n            fmt.Println(\"3\")\n        }()\n    }()\n    fmt.Println(\"Hello, 世界\")\n}\n```\n运行结果\n```\n3\n2\n1\npanic: after 2\n\ngoroutine 1 [running]:\nmain.main.func1.2()\n    /tmp/sandbox153708588/main.go:14 +0x100\nmain.main.func1()\n    /tmp/sandbox153708588/main.go:20 +0xbb\nmain.main()\n    /tmp/sandbox153708588/main.go:20 +0x20\n```\n这样的话123就会全部执行了。\n\n### defer调用函数时，参数在声明的一刻就已经确定了\ndefer调用函数时，参数在声明的一刻就已经确定了，即使参数变量在以后会有变化，也不会影响defer调用。（个人猜想：defer声明时会把所需参数变量当前值入栈，函数结束后变量已经不再存在），\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    func() {\n        i := 0\n        defer func(j int) {\n            fmt.Println(\"i = \", i)\n            fmt.Println(\"j = \", j)\n        }(i + 1)\n        i = 3\n    }()\n    fmt.Println(\"Hello, 世界\")\n}\n```\nresult:\n```\ni =  3\nj =  1\nHello, 世界\n```\n```i+1```表达式在defer声明的一刻就已经计算出来了，不会再受后面程序的影响 （***注：闭包的特性没有受影响***）\n\n还有一个golang官方的例子，贴出来：\n```go\nfunc trace(s string) string {\n    fmt.Println(\"entering:\", s)\n    return s\n}\n\nfunc un(s string) {\n    fmt.Println(\"leaving:\", s)\n}\n\nfunc a() {\n    defer un(trace(\"a\"))\n    fmt.Println(\"in a\")\n}\n\nfunc b() {\n    defer un(trace(\"b\"))\n    fmt.Println(\"in b\")\n    a()\n}\n\nfunc main() {\n    b()\n}\n```\nprints\n```\nentering: b\nin b\nentering: a\nin a\nleaving: a\nleaving: b\n```","cover":"","link":"golang_defer.html","preview":"","title":"golang defer"}]